/*
<javascriptresource>
<name>Normalization Tool for PSD File/name>
<menu>auto</menu>
<enableinfo>true</enableinfo>
<eventid>a8d5ff70-d981-11eb-b8bc-0242ac130003</eventid>
<terminology><![CDATA[<<
/Version 1
>> ]]></terminology>
</javascriptresource>
*/
"use strict";

function newProgressWindow(title, min, max) {
  var win = new Window("palette", title);
  win.bar = win.add("progressbar", undefined, min, max);
  win.bar.preferredSize = [300, 20];
  win.parent = undefined;
  win.updateProgress = function (val) {
    var win = this;
    win.bar.value = val;
    win.show();
    win.hide();
    win.show();
  };
  win.center(win.parent);
  return win;
}

// Apply forEachItem function on all items generated by genList,
// may be reverse by setting reverse parameters to true.
// return a function that consume doc & onProgress function,
// where onProgress is a function that consume progress item count & total count.
function forAll(genList, forEachItem, reverse) {
  return function (doc, onProgress) {
    var list = genList(doc);
    var itemCount = list.length;
    if (reverse) {
      var cnt = 0;
      for (var i = itemCount - 1; i >= 0; i--) {
        cnt++;
        onProgress(cnt, itemCount);
        var item = list[i];
        try {
          forEachItem(doc, item);
        } catch (e) {
          $.writeln(forEachItem.name + "[" + i + "] at " + e.line + ":" + e);
        }
      }
    } else {
      for (var i = 0; i < itemCount; i++) {
        onProgress(i + 1, itemCount);
        var item = list[i];
        try {
          forEachItem(doc, item);
        } catch (e) {
          $.writeln(forEachItem.name + "[" + i + "] at " + e.line + ":" + e);
        }
      }
    }
  };
}

function genIterWork(genList, forEachLayer, reverse) {
  return {
    tag: "forAll(" + genList.name + ") => " + forEachLayer.name,
    func: forAll(genList, forEachLayer, reverse),
  };
}

// Wrapper function for all normalization normWorks
function normalizeForPsd2UI(doc) {
  var normWorks = [
    genIterWork(getAllLayerSets, mergeLayerSetIfNeed, false),
    genIterWork(getAllArtLayers, unlockAndSetVisible, false),
    genIterWork(getAllArtLayers, mergeMaskedLayer, true),
    genIterWork(getAllClippingMaskedLayers, mergeDownLayer, true),
    genIterWork(getAllArtLayers, mergeStyledLayer, true),
    genIterWork(getAllArtLayers, deleteEmptyLayer, false),
    { tag: "deleteAllEmptyLayerSets", func: deleteAllEmptyLayerSets },
  ];

  var title = "Doing PSD2UI normalization, please wait...";
  var progWin = newProgressWindow(title, 0, 100);
  try {
    progWin.updateProgress(0);
    var step = 1 / normWorks.length;
    var curr = 0;
    for (var i = 0; i < normWorks.length; i++) {
      var work = normWorks[i];
      $.writeln(work.tag);
      work.func(doc, function (idx, total) {
        progWin.updateProgress((curr + (idx / total) * step) * 100);
      });
      curr += step;
      progWin.updateProgress(curr * 100);
    }
  } catch (e) {}
  progWin.close();
}

// See if there is a raster layer mask
function hasLayerMask() {
  var hasLayerMask = false;
  try {
    var ref = new ActionReference();
    var keyUserMaskEnabled = cTID("UsrM");
    ref.putProperty(cTID("Prpr"), keyUserMaskEnabled);
    ref.putEnumerated(cTID("Lyr "), cTID("Ordn"), cTID("Trgt"));
    var desc = executeActionGet(ref);
    if (desc.hasKey(keyUserMaskEnabled)) {
      hasLayerMask = true;
    }
  } catch (e) {
    hasLayerMask = false;
    $.writeln("hasLayerMask at " + e.line + ":" + e);
  }
  return hasLayerMask;
}

// See if there is a Smart Filter mask
function hasFilterMask() {
  var hasFilterMask = false;
  try {
    var ref = new ActionReference();
    var keyFilterMask = app.stringIDToTypeID("hasFilterMask");
    ref.putProperty(app.charIDToTypeID("Prpr"), keyFilterMask);
    ref.putEnumerated(
      app.charIDToTypeID("Lyr "),
      app.charIDToTypeID("Ordn"),
      app.charIDToTypeID("Trgt")
    );
    var desc = executeActionGet(ref);
    if (desc.hasKey(keyFilterMask) && desc.getBoolean(keyFilterMask)) {
      hasFilterMask = true;
    }
  } catch (e) {
    hasFilterMask = false;
  }
  return hasFilterMask;
}

// See if there is a vector layer mask
function hasVectorMask() {
  var hasVectorMask = false;
  try {
    var ref = new ActionReference();
    var keyVectorMaskEnabled = app.stringIDToTypeID("vectorMask");
    var keyKind = app.charIDToTypeID("Knd ");
    ref.putEnumerated(
      app.charIDToTypeID("Path"),
      app.charIDToTypeID("Ordn"),
      keyVectorMaskEnabled
    );
    var desc = executeActionGet(ref);
    if (desc.hasKey(keyKind)) {
      var kindValue = desc.getEnumerationValue(keyKind);
      if (kindValue == keyVectorMaskEnabled) {
        hasVectorMask = true;
      }
    }
  } catch (e) {
    hasVectorMask = false;
  }
  return hasVectorMask;
}

// See if these is a clipping mask layer
function hasClippingMask() {
  var hasClipping = false;
  try {
    var ref = new ActionReference();
    ref.putEnumerated(cTID("Lyr "), cTID("Ordn"), cTID("Trgt"));
    var desc = executeActionGet(ref);
    hasClipping = desc.hasKey(cTID("Grup")) && desc.getBoolean(cTID("Grup"));
  } catch (e) {
    hasClipping = false;
    $.writeln("hasClippingMask at " + e.line + ":" + e);
  }
  return hasClipping;
}

function unlockAndSetVisible(doc, layerOrSet) {
  layerOrSet.locked = false;
  if (layerOrSet.visible == false) {
    layerOrSet.visible = true;
  }
}

function mergeLayerSetIfNeed(doc, layerSet) {
  unlockAndSetVisible(doc, layerSet);
  if (layerSet.layers.length === 0) {
    return;
  }
  var groupName = layerSet.name;
  doc.activeLayer = layerSet;
  if (layerSet.name.startsWith("merge")) {
    var newName = groupName.slice("merge".length).trim();
    if (newName.length === 0) {
      newName = "noname";
    }
    var newLayer = layerSet.merge();
    newLayer.name = newName;
  } else if (hasLayerStyle() || hasLayerMask()) {
    var newLayer = layerSet.merge();
    newLayer.name = groupName;
  }
}

function mergeStyledLayer(doc, layer) {
  doc.activeLayer = layer;
  if (hasLayerStyle() && (!onlyHasDropShadowOrOutlineStyle())) {
    var targetLayer = app.activeDocument.activeLayer.name; // Remember the layers name
    makeLayerBelow(targetLayer); // Make a new layer below with the target layers name
    selectPreviousLayer(); // select the previous layer
    mergeDown(); // and merge it down
  }
}

// Rasterize the current layer to pixels
function rasterizeLayer() {
  try {
    var id1242 = sTID("rasterizeLayer");
    var desc245 = new ActionDescriptor();
    var ref184 = new ActionReference();
    ref184.putEnumerated(cTID("Lyr "), cTID("Ordn"), cTID("Trgt"));
    desc245.putReference(cTID("null"), ref184);
    executeAction(id1242, desc245, DialogModes.NO);
  } catch (e) {
    $.writeln("rasterizeLayer at " + e.line + ":" + e);
  }
}

// Rasterize the vector mask on the current layer to pixels
function rasterizeVectorMask() {
  try {
    var id488 = stringIDToTypeID("rasterizeLayer");
    var desc44 = new ActionDescriptor();
    var id489 = charIDToTypeID("null");
    var ref29 = new ActionReference();
    var id490 = charIDToTypeID("Lyr ");
    var id491 = charIDToTypeID("Ordn");
    var id492 = charIDToTypeID("Trgt");
    ref29.putEnumerated(id490, id491, id492);
    desc44.putReference(id489, ref29);
    var id493 = charIDToTypeID("What");
    var id494 = stringIDToTypeID("rasterizeItem");
    var id495 = stringIDToTypeID("vectorMask");
    desc44.putEnumerated(id493, id494, id495);
    executeAction(id488, desc44, DialogModes.NO);
  } catch (e) {
    $.writeln("rasterizeVectorMask at " + e.line + ":" + e);
  }
}

// Select the layer mask on the current layer
function selectLayerMask() {
  try {
    var desc153 = new ActionDescriptor();
    var ref92 = new ActionReference();
    ref92.putEnumerated(cTID("Chnl"), cTID("Chnl"), cTID("Msk "));
    desc153.putReference(cTID("null"), ref92);
    desc153.putBoolean(cTID("MkVs"), false);
    executeAction(cTID("slct"), desc153, DialogModes.NO);
  } catch (e) {
    $.writeln("selectLayerMask at " + e.line + ":" + e);
  }
}

// Select the vector mask on the current layer
function selectVectorMask() {
  try {
    var id55 = charIDToTypeID("slct");
    var desc15 = new ActionDescriptor();
    var id56 = charIDToTypeID("null");
    var ref13 = new ActionReference();
    var id57 = charIDToTypeID("Path");
    var id58 = charIDToTypeID("Path");
    var id59 = stringIDToTypeID("vectorMask");
    ref13.putEnumerated(id57, id58, id59);
    var id60 = charIDToTypeID("Lyr ");
    var id61 = charIDToTypeID("Ordn");
    var id62 = charIDToTypeID("Trgt");
    ref13.putEnumerated(id60, id61, id62);
    desc15.putReference(id56, ref13);
    executeAction(id55, desc15, DialogModes.NO);
  } catch (e) {
    $.writeln("selectVectorMask at " + e.line + ":" + e);
  }
}

// Apply the vector mask on the current layer
function applyLayerMask() {
  try {
    var desc154 = new ActionDescriptor();
    var ref93 = new ActionReference();
    ref93.putEnumerated(cTID("Chnl"), cTID("Ordn"), cTID("Trgt"));
    desc154.putReference(cTID("null"), ref93);
    desc154.putBoolean(cTID("Aply"), true);
    executeAction(cTID("Dlt "), desc154, DialogModes.NO);
  } catch (e) {
    $.writeln("applyLayerMask at " + e.line + ":" + e);
  }
}

// Get a reference to all artLayers in doc
function getAllArtLayers(doc, visibles) {
  var allArtLayers = new Array();
  getAllArtLayersRec(doc, allArtLayers);
  return allArtLayers;
}

function getAllArtLayersRec(layerContainer, layers, visibles) {
  for (var i = 0; i < layerContainer.artLayers.length; i++) {
    layers.push(layerContainer.artLayers[i]);
    if (visibles !== undefined) {
      visibles.push(layerContainer.artLayers[i].visible);
    }
  }
  for (var i = 0; i < layerContainer.layerSets.length; i++) {
    getAllArtLayersRec(layerContainer.layerSets[i], layers, visibles);
  }
}

// Get a reference to all layerSets in doc
function getAllLayerSets(doc, visibles) {
  var allLayerSets = new Array();
  getAllLayerSetsRec(doc, allLayerSets, visibles);
  return allLayerSets.reverse();
}

function getAllLayerSetsRec(layerContainer, layerSets, visibles) {
  for (var i = 0; i < layerContainer.layerSets.length; i++) {
    layerSets.push(layerContainer.layerSets[i]);
    if (visibles !== undefined) {
      visibles.push(layerContainer.layerSets[i].visible);
    }
    getAllLayerSetsRec(layerContainer.layerSets[i], layerSets); // recursive call
  }
}

// Get a reference to all art layers with clipping mask
function getAllClippingMaskedLayers(doc) {
  var allArtLayers = getAllArtLayers(doc);
  var allClippingLayers = new Array();
  for (var i = 0; i < allArtLayers.length; i++) {
    doc.activeLayer = allArtLayers[i];
    if (hasClippingMask()) {
      allClippingLayers.push(allArtLayers[i]);
    }
  }
  return allClippingLayers;
}

function mergeMaskedLayer(doc, layer) {
  doc.activeLayer = layer;
  if (hasVectorMask()) {
    rasterizeLayer(); // Rasterize the layer in case it's a fill layer, smart object, video or 3D layer (since you can't apply masks to these kinds of layers)
    selectVectorMask(); // Select the vector mask
    rasterizeVectorMask(); // rasterize the vector mask
    applyLayerMask(); // Apply the layer mask
  }
  if (hasLayerMask()) {
    rasterizeLayer(); // Rasterize the layer in case it's a fill layer, smart object, video or 3D layer (since you can't apply masks to these kinds of layers)
    selectLayerMask(); // Select the layer mask
    applyLayerMask(); // Apply the layer mask
  }
  if (hasFilterMask() == true) {
    rasterizeLayer(); // Rasterize the layer - It's the only way to apply a Smart Filter Mask
  }
}

function mergeDownLayer(doc, layer) {
  doc.activeLayer = layer;
  mergeDown();
}

// See if there are styles present on a layer
function hasLayerStyle() {
  var hasLayerStyle = false;
  try {
    var ref = new ActionReference();
    var keyLayerEffects = cTID("Lefx");
    ref.putProperty(cTID("Prpr"), keyLayerEffects);
    ref.putEnumerated(cTID("Lyr "), cTID("Ordn"), cTID("Trgt"));
    var desc = executeActionGet(ref);
    if (desc.hasKey(keyLayerEffects)) {
      hasLayerStyle = true;
    }
  } catch (e) {
    hasLayerStyle = false;
    $.writeln("hasLayerStyle at " + e.line + ":" + e);
  }
  return hasLayerStyle;
}

function hasOneLayerStyle(styleID)
{
  var hasStyle = false;
  var ref = new ActionReference();
  var keyLayerEffects = cTID("Lefx");
  ref.putProperty(cTID("Prpr"), keyLayerEffects);
  ref.putEnumerated(cTID("Lyr "), cTID("Ordn"), cTID("Trgt"));
  var desc = executeActionGet(ref);
  var layerEffects = desc.getObjectValue(cTID('Lefx'));
  if (layerEffects)
  {
      if (layerEffects.hasKey(styleID))
      {
        var objStyle = layerEffects.getObjectValue(styleID);
        if (objStyle)
        {
          hasStyle = objStyle.getBoolean(cTID("enab"));
        }
      }
  }

  return hasStyle;
}

function onlyHasDropShadowOrOutlineStyle()
{
   var onlyHas = hasOneLayerStyle(cTID("FrFX")) || hasOneLayerStyle(cTID("DrSh"));
   var hasOtherStyle = hasOneLayerStyle(cTID("ebbl")) || hasOneLayerStyle(cTID("IrSh")) || hasOneLayerStyle(cTID("IrGl")) || hasOneLayerStyle(cTID("ChFX")) || hasOneLayerStyle(cTID("SoFi")) || hasOneLayerStyle(cTID("GrFl")) || hasOneLayerStyle(sTID("patternFill")) || hasOneLayerStyle(cTID("OrGl"));
   onlyHas = onlyHas && (!hasOtherStyle);
   return onlyHas;
}

// Creates a new layer below with the target layers name
function makeLayerBelow(targetName) {
  try {
    var id829 = cTID("Mk  ");
    var desc169 = new ActionDescriptor();
    var id830 = cTID("null");
    var ref105 = new ActionReference();
    var id831 = cTID("Lyr ");
    ref105.putClass(id831);
    desc169.putReference(id830, ref105);
    var id832 = sTID("below");
    desc169.putBoolean(id832, true);
    var id833 = cTID("Usng");
    var desc170 = new ActionDescriptor();
    var id834 = cTID("Nm  ");
    desc170.putString(id834, targetName);
    var id835 = cTID("Lyr ");
    desc169.putObject(id833, id835, desc170);
    executeAction(id829, desc169, DialogModes.NO);
  } catch (e) {
    // do nothing
    $.writeln("makeLayerBelow at " + e.line + ":" + e);
  }
}

// Selects the layer above the selected layer, adding that layer to the current layer selection
function selectPreviousLayer() {
  try {
    var idslct = cTID("slct");
    var desc9 = new ActionDescriptor();
    var idnull = cTID("null");
    var ref8 = new ActionReference();
    var idLyr = cTID("Lyr ");
    var idOrdn = cTID("Ordn");
    var idFrwr = cTID("Frwr");
    ref8.putEnumerated(idLyr, idOrdn, idFrwr);
    desc9.putReference(idnull, ref8);
    var idselectionModifier = sTID("selectionModifier");
    var idselectionModifierType = sTID("selectionModifierType");
    var idaddToSelection = sTID("addToSelection");
    desc9.putEnumerated(
      idselectionModifier,
      idselectionModifierType,
      idaddToSelection
    );
    var idMkVs = cTID("MkVs");
    desc9.putBoolean(idMkVs, false);
    executeAction(idslct, desc9, DialogModes.NO);
  } catch (e) {
    // do nothing
    $.writeln("selectPreviousLayer at " + e.line + ":" + e);
  }
}

function mergeDown() {
  try {
    var desc168 = new ActionDescriptor();
    executeAction(cTID("Mrg2"), desc168, DialogModes.NO);
  } catch (e) {
    // do nothing
    $.writeln("mergeDown at " + e.line + ":" + e);
  }
}

function tryRun(func) {
  try {
    return func();
  } catch (e) {
    $.writeln("doWithDialogMode unexcept error at " + e.line + ": " + e);
  }
  return undefined;
}

function isLockedOrLinked(layer) {
  return (
    layer.allLocked ||
    layer.pixelsLocked ||
    layer.positionLocked ||
    layer.transparentPixelsLocked ||
    layer.linkedLayers.length !== 0
  );
}

// delete layer which contains no image and text
function deleteEmptyLayer(doc, layer) {
  if (isLockedOrLinked(layer)) {
    return; // skip locked or linked
  }

  if (LayerKind.TEXT == layer.kind && "" == layer.textItem.contents) {
    layer.remove();
  } else if (0 == layer.bounds[2] && 0 == layer.bounds[3]) {
    layer.remove();
  }
}

// delete all layer sets which contains no sub layers
// layerContainer can be doc or layerSet
function deleteAllEmptyLayerSets(layerContainer) {
  try {
    var isEmpty = true;
    for (var i = layerContainer.layerSets.length - 1; 0 <= i; i--) {
      var layerSet = layerContainer.layerSets[i];
      if (layerSet.allLocked || 0 != layerSet.linkedLayers.length) {
        continue; // skip locked or linked
      }
      if (deleteAllEmptyLayerSets(layerSet)) {
        layerSet.remove(); // delete
      } else {
        isEmpty = false; // not empty
      }
    }
    if (0 != layerContainer.artLayers.length) {
      isEmpty = false; // not empty
    }
  } catch (e) {
    $.writeln("deleteAllEmptyLayerSets unexcept error at " + e.line + ": " + e);
  }
  return isEmpty;
}

function doWithDialogMode(func, mode) {
  if (mode === undefined) {
    return tryRun(func);
  }
  var currMode = app.displayDialogs;
  app.displayDialogs = mode;
  var ret = tryRun(func);
  app.displayDialogs = currMode;
  return ret;
}

// save the given in specific path
function saveDocument(doc, path) {
  return doWithDialogMode(function () {
    var saveOpts = new PhotoshopSaveOptions();
    saveOpts.layers = true;
    saveOpts.embedColorProfile = true;
    saveOpts.annotations = true;
    saveOpts.alphaChannels = true;
    var file = new File(path);
    doc.saveAs(file, saveOpts, true);
    // file.close();
    return file.toUIString();
    // });
  }, DialogModes.ALL);
}

// Main function
function main() {
  app.bringToFront();

  var originalRulerUnits = app.preferences.rulerUnits; // remember current setting
  app.preferences.rulerUnits = Units.PIXELS; // set Pixel for checking bounds

  var baseName = app.activeDocument.name.substr(
    0,
    app.activeDocument.name.lastIndexOf(".")
  );
  var newFileName = baseName + "_norm.psd";
  var savePath = app.activeDocument.path.fsName + "/" + newFileName;

  doWithDialogMode(function () {
    var docCp = app.activeDocument.duplicate();
    app.activeDocument = docCp;
    normalizeForPsd2UI(docCp);
    var path = saveDocument(docCp, savePath);
    if (path) {
      $.writeln("document has been saved as " + path);
    }
    app.activeDocument.close(SaveOptions.DONOTSAVECHANGES);
    // alert("File has been export to " + newFileName, "Done Normalization");
  }, DialogModes.ERROR);

  app.preferences.rulerunits = originalRulerUnits; // restore unit
}

$.writeln("Normalization start!");
main();